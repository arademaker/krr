
(in-package :fol)

(defun variable? (x)
  (and (symbolp x)
       (equal (char (symbol-name x) 0) #\?)))

(defun length-form (form)
  (if (> (length form) 0)
      (if (atom (car form))
          (if (member (car form) '(implies and or equiv))
              (+ 1 (length-form (cdr form)))
              (length-form (cdr form)))
          (+ (length-form (car form)) (length-form (cdr form))))
      0))


(defun preproc (formula &optional (i 1))
  (cond 
    ((and formula
	  (atom formula)
	  (symbolp formula))
     (values formula i))
    ((and (= (length formula) 3)
	  (equal (car formula) 'equiv))
     (multiple-value-bind (f k)
	 (pre-aux (cdr formula) i)
       (values `(and (implies ,f) (implies ,(reverse f))) k)))	
    ((and (listp formula)
          (equal (car formula) 'not)
	  (= (length formula) 2))
     (multiple-value-bind (f k)
	 (preproc (cadr formula) i)
       (values `(not ,f) k)))
    ((and (listp formula)
	  (equal (car formula) 'implies)
	  (= (length formula) 3))
     (multiple-value-bind (f k)
	 (pre-aux (cdr formula) i)
       (values (cons 'implies f) k)))
    ((and (listp formula)
	  (member (car formula) '(and or) :test #'equal)
	  (= (length formula) 2))
     (preproc (cadr formula) i))
    ((and (listp formula)
	  (member (car formula) '(and or) :test #'equal)
	  (> (length formula) 2))
     (multiple-value-bind (f k)
	 (pre-aux (cdr formula) i)
       (values (reduce (lambda (x y) (list (car formula) x y)) f) k)))
    ((and (listp formula)
	  (> (length formula) 1)
	  (symbolp (car formula))
	  (every #'variable? (cdr formula)))
     (values formula i))
    ((and (listp formula)
          (member (car formula) '(exists forall) :test #'equal)
          (variable? (cadr formula))
          (= (length formula) 3))
     (multiple-value-bind (f k)
	 (preproc (caddr formula) (+ i 1))
       (values (sublis `((,(cadr formula) . ,(intern (format nil "?X~a" i))))
		       `(,(car formula) ,(cadr formula) ,f))
	       k)))
    (t (error "Invalid Formula ~a" formula)))) 
    
    
(defun pre-aux (frms i)
  (do ((f frms (cdr f))
       (k i)
       (result nil))
      ((null f) (values (reverse result) k))
      (multiple-value-bind (form j)
	(preproc (car f) k)
	  (progn (push form result)
		 (setf k j)))))    

