(in-package :fol)


(defun variable? (v)
  (and (symbolp v)
       (equal (elt (symbol-name v) 0) #\?)))
       

(defun preproc (formula &optional (i 1))
  (cond 
    ((and formula
					(atom formula)
					(symbolp formula))
			(values formula i))
    ((and (= (length formula) 3)
				  (equal (car formula) 'equiv))
      (multiple-value-bind (f k) (pre-aux (cdr formula) i)
							(values `(and (implies ,f) (implies ,(reverse f))) k)))	
		((and (listp formula)
			  	(equal (car formula) 'not)
			  	(= (length formula) 2))
      (multiple-value-bind (f k) (preproc (cadr formula) i)
							(values `(not ,f) k)))
    ((and (listp formula)
	        (equal (car formula) 'implies)
				  (= (length formula) 3))
     (multiple-value-bind (f k) (pre-aux (cdr formula) i)
							(values (cons 'implies f) k)))
    ((and (listp formula)
					(member (car formula) '(and or) :test #'equal)
					(= (length formula) 2))
     (preproc (cadr formula) i))
    ((and (listp formula)
					(member (car formula) '(and or) :test #'equal)
					(> (length formula) 2))
     (multiple-value-bind (f k) (pre-aux (cdr formula) i)
							(values (reduce (lambda (x y) (list (car formula) x y)) f) k)))
    ((and (listp formula)
					(> (length formula) 1)
					(symbolp (car formula))
					(every #'variable? (cdr formula)))
     (values formula i))
    ((and (listp formula)
          (member (car formula) '(exists forall) :test #'equal)
          (variable? (cadr formula))
          (= (length formula) 3))
		 (multiple-value-bind (f k) (preproc (caddr formula) (+ i 1))
							(values (sublis `((,(cadr formula) . ,(intern (format nil "?X~a" i))))
															`(,(car formula) ,(cadr formula) ,f))
											k)))
    (t (error "Invalid Formula ~a" formula)))) 
    
    
(defun pre-aux (frms i)
	(do ((f frms (cdr f))
			 (k i)
			 (result nil))
			((null f) (values (reverse result) k))
			(multiple-value-bind (form j)
				(preproc (car f) k)
					(progn (push form result)
								 (setf k j)))))    
